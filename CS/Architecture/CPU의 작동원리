* ALU와 제어장치
- ALU(Arithmetic Logic Unit) : 산술/논리 연산장치

ALU는 레지스터로부터 피연산자를 전달받고, 제어장치로부터 제어신호를 전달받아 산술/논리연산을 수행한 뒤에 메모리가 아닌, 레지스터에 우선 저장한다.
-> WHY?
* CPU가 메모리에 접근하는 속도 >>>>> CPU가 레지스터에 접근하는 속도(당연하지. 레지스터는 CPU 내부에 있는거니까.)
이것이 ALU가 연산 결과를 레지스터에 저장하는 이유이다. CPU가 빨리 가져다 쓰려고 ㅋㅋ


* ALU는 산술/논리연산의 결과 뿐 아니라, 여러 플래그(flag)도 플래그 레지스터에 전달한다.
플래그는 0과 1로 표현하며, 플래그가 켜지면 1, 그렇지 않으면 0.
- 부호 플래그 : 음수인지 양수인지. 1일 경우 음수, 0일 경우 양수
- 제로 플래그 : 0인지 아닌지. 1일 경우 0
- 캐리 플래그 : 자리올림이 발생했는지. 1일 경우 자리올림
- 오버플로우 플래그 : 오버플로우(연산 결과가 연산결과를 담을 레지스터보다 큰 상황) 발생 시. 1일 경우 오버플로우
- 인터럽트 플래그 : 인터럽트가 가능한지. 1일 경우 인터럽트 가능
- 슈퍼바이저 플래그 : 커널모드인지 사용자모드인지. 1일 경우 커널모드, 0일 경우 사용자모드


* 제어장치

제어장치는 제어신호를 내보내고 명령어를 해석하는 부품. 그냥 컴퓨터의 모든 부품을 제어하는 CPU의 핵심.

- 받아들이는 것
1. 클럭(clock) : 컴퓨터의 모든 부품을 시간단위로 움직이도록 하는 신호. 이 클럭 신호의 박자에 맞춰 데이터가 이동하거나 한다.
2. 명령어 : 명령어 레지스터로부터 해석해야 할 명령어를 받아들이고 해석한 후, 제어 신호를 발생시켜 부품들에게 알려준다.
3. 플래그 : 플래그 레지스터로부터 플래그를 받아들이고 해석한 후, 제어 신호를 발생시킨다.
4. 제어 신호 : CPU뿐만 아니라, 외부의 부품들로부터 발생된 제어 신호를 제어 버스를 통해 받아들인다. 

- 내보내는 것 == 제어 신호
1. CPU 내부로 보내는 제어 신호 : ALU에게 수행할 연산을 지시하기 위해,  레지스터에게 데이터의 이동과 명령어의 해석을 위해 제어 신호를 내보낸다. 
2. CPU 외부로 보내는 제어 신호 : 메모리에게 메모리의 값을 읽거나 쓰기위해, 입출력 장치에게 입출력 장치의 값을 읽거나 쓰기위해 제어 버스를 통해 제어 신호를 내보낸다.

-----------------------------------------------------------------------------------------------------------------------
* 레지스터

CPU 내부의 임시 저장공간. CPU가 메모리 직접 도달하는 시간이 오래걸리는 문제를 해결하기 위한 부품.

* 프로그램 실행 과정에서 레지스터의 작동 순서를 알아두자(혼공 116p. 참조)

* 종류(CPU 제조사마다 다르지만, 공통적으로 사용하는 레지스터들을 알아두자)
- 프로그램 카운터      : 메모리에서 가져올 명령어의 주소를 저장.
- 메모리 주소 레지스터 : CPU에서 특정 주소의 메모리의 값을 읽고싶을 때 주소 버스로 메모리에 전달하는 주소를 저장.
- 메모리 버퍼 레지스터 : 메모리에서 데이터 버스를 통해 전달받은 '값'을 저장. 이 때, 프로그램 카운터는 +1 되어 다음 주소를 읽을 준비를 한다.
- 명령어 레지스터      : 메모리 버퍼 레지스터의 값이 이곳에 저장.
- 플래그 레지스터      : ALU가 보낸 플래그를 저장.
- 범용 레지스터        : 메모리 주소, 메모리 버퍼 레지스터는 각각 주소 버스와 데이터 버스로 주소와 데이터만 저장하지만, 범용 레지스터는 둘 다 저장할 수 있다!!
- 스택 포인터          : 스택 영역의 꼭대기를 가리키는 레지스터. 즉, 스택에 마지막으로 저장된 값의 주소를 저장.
- 베이스 레지스터      : '기준(Base) 주소'를 저장하며, 명령어의 오퍼랜드에 입력된 다른 값과 연산하여 이곳에 저장된 기준 주소에서 해당 값만큼 이동할 수 있는 로직을 실행할 수 있도록 함.

-----------------------------------------------------------------------------------------------------------------------
* 명령어 사이클과 인터럽트

- 명령어 사이클 : 하나의 명령어가 처리되는 주기.
- 인터럽트(interrupt) : 방해하다. 중단시키다. 즉, 그 명령어 사이클이 방해받는 상황.

* 명령어 사이클은 인출, 실행, 간접, 인터럽트 사이클 총 네가지로 구성돼있다.
- 인출 사이클 : 처리할 명령어를 메모리에서 CPU로 가져오는 사이클. 프로그램 카운터부터 명령어 레지스터에 메모리가 저장되는 과정까지가 인출 사이클이다.
- 실행 사이클 : 명령어를 실행하는 사이클. 제어장치가 명령어 레지스터에 저장된 값을 해석하고, 제어 신호를 발생시키는 과정.
- 간접 사이클 : 명령어 실행을 위해 메모리 접근을 한번 더 해야할 경우에 간접 사이클을 거침.(간접 주소 지정 방식일 경우 간접 주소를 가져온 것이니까)
- 인터럽트 사이클 : CPU의 작업을 방해하는 인터럽트의 사이클.


* 인터럽트(interrupt)
- 동기 인터럽트(Synchronous interrupts) == '예외' : CPU에 의해 발생하는 인터럽트. CPU가 명령어를 실행하다가 예상치 못한 상황을 마주했을 경우. 
- 비동기 인터럽트(Asynchronous interrupts) == 하드웨어 인터럽트 : 입출력장치에 의해 발생하는 인터럽트. 알림과 같은 것들. 
                                                                 (ex. '프린트 완료'라는 비동기 인터럽트를 받을 때까지 CPU는 다른 작업을 하면 됨)

* 동기 인터럽트(예외) 종류
- Fault : 예외 처리 직후, 예외가 발생한 명령어부터 다시 실행.(명령어 수행에 필요한 데이터가 메모리에 없을 경우, 메모리에 적재한 후 그 명령어부터 다시 실행)
- Trap : 예외 처리 직후, 예외가 발생한 명령어의 다음 명령어부터 실행.(디버깅 할 때)
- Abort : CPU가 프로그램을 강제로 중단해야 하는 심각한 오류를 발견했을 경우 abort 발생.
- Software interrupt : 시스템 호출시 발생

* 비동기 인터럽트 처리 순서
1. 입출력장치는 CPU에 '인터럽트 요청 신호'를 보냄.(인터럽트 해도 되나요 CPU님?)
2. CPU는 실행사이클이 끝나고 다시 인출 사이클로 들어가기 전에 항상 인터럽트 여부를 확인함.
3. 플래그 레지스터의 '인터럽트 플래그'가 '불가능'일 경우, 인터럽트를 무시.
3. 인터럽트 플래그가 '가능'일 경우, CPU는 하던 작업을 스택에 저장한 후, 입출력 장치가 CPU에 보내준 '인터럽트 벡터'로 주소를 참조해 '인터럽트 서비스 루틴'을 실행.
4. 인터럽트 서비스 루틴을 실행 후 스택에 저장돼있는 원래 하던 작업의 주소를 참조해 해당 작업을 이어서 수행.

* 무시할 수 없는 인터럽트도 있다!
정전이나 하드웨어 고장으로 인한 인터럽트는 무시할 수 없지... 그래서 비동기 인터럽트에는 무시할 수 있는 인터럽트와 무시할 수 없는 인터럽트가 있다.

